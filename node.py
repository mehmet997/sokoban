import copy

from HeuristicFunctionModeEnum import HeuristicFunctionMode


from direction import *

class Node(object):
    n = 0

    def __init__(self, action, parent, g, game, heuristic = None):
        """
        self.action = action used to generate this state from parent
        self.parent = the parent state. A state is generated by performing an action in the parent state
        self.g = costs to get to this state (integer)
        """

        self.action = action
        self.parent = parent
        self.g = g

        self.game = game
        if heuristic:
            if heuristic == HeuristicFunctionMode.MANHATTAN:
                self.h = self.manhattan_distance()
        else: self.h = None
        self.heuristic = heuristic


    def expand(self):
        """generates the possible successor states from the current state
        i.e. all states that come from the movements
            UP, DOWN, LEFT, RIGHT"""
        successors = []
        for direction in (UP, RIGHT, DOWN, LEFT):
            # print(direction.movement[0])
            # print(direction.movement[1])
            gamecopy = copy.deepcopy(self.game)
            canmove = gamecopy.can_move(direction.movement[0], direction.movement[1]) or gamecopy.can_push(
                direction.movement[0], direction.movement[1])
            if canmove:
                gamecopy.move(direction.movement[0], direction.movement[1], True)
                s = Node(direction, self, self.g + 1, gamecopy, self.heuristic)
                successors.append(s)
        return successors

    def goal(self):
        """goal predicate"""
        return self.game.is_completed()

    def eval(self):
        if not self.h:
            return self.g
        else:
            return self.h+self.g

    def manhattan_distance(self):
        """returns the sum of the manhattan distances of every box
        there are many boxes and many storages, so for each box
        I take the smallest manhattan distance amongst them
        H(M): |xA − xB | + |yA − yB |
        """
        manhattan = 0
        box_coordinates = self.__coordinates("$")
        storage_coordinates = self.__coordinates(".")
        for box in box_coordinates:
            min_distance = None
            for storage in storage_coordinates:
                distance = abs(box[0]-storage[0])+ abs(box[1]-storage[1])
                if not min_distance: min_distance=distance
                elif min_distance>distance:min_distance=distance
            if min_distance:
                manhattan=manhattan+min_distance
        return manhattan

    def __coordinates(self, character):
        coordinates = []
        for row_index, row in enumerate(self.game.matrix):
            if character in row:
                indices = [i for i, x in enumerate(row) if x == character]
                for col_index in indices:
                    coordinates.append((row_index, col_index))
        return coordinates


    def __ne__(self, other):
        return not (self == other)

    def __lt__(self, other):
        return self.eval() < other.eval()

    def __gt__(self, other):
        return self.eval() > other.eval()

    def __le__(self, other):
        return (self < other) or (self == other)

    def __ge__(self, other):
        return (self > other) or (self == other)





